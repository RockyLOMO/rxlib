package org.rx.jdbc;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.Setter;
import lombok.SneakyThrows;
import org.rx.core.Reflects;

import java.sql.*;

import static org.rx.core.Contract.proxy;

public abstract class SuperStatement extends SuperJdbc implements Statement {
    @Getter
    @Setter
    private int maxRows;
    @Getter
    @Setter
    private int queryTimeout; //seconds
    @Getter
    @Setter(AccessLevel.PROTECTED)
    private boolean closeOnCompletion;
    @Getter
    private ResultSet resultSet;
    @Getter
    private int updateCount;

    protected void setResultSet(ResultSet resultSet) {
        this.resultSet = resultSet;
        updateCount = -1;
    }

    protected void setUpdateCount(int updateCount) {
        this.updateCount = updateCount;
        resultSet = null;
    }

    @Override
    public int getMaxFieldSize() {
        return 0;
    }

    @Override
    public void setMaxFieldSize(int max) {
    }

    @Override
    public void setEscapeProcessing(boolean enable) {
    }

    @Override
    public SQLWarning getWarnings() {
        return null;
    }

    @Override
    public void clearWarnings() {
    }

    @Override
    public void setCursorName(String name) {
    }

    @SneakyThrows
    @Override
    public boolean execute(String sql) {
        boolean query = JdbcUtil.isQuery(sql);
        if (query) {
            ResultSet wrap = executeQuery(sql);
            setResultSet(proxy(ResultSet.class, (m, p) -> {
                if (Reflects.isCloseMethod(m) && closeOnCompletion) {
                    this.close();
                    return null;
                }
                return p.fastInvoke(wrap);
            }));
        } else {
            setUpdateCount(executeUpdate(sql));
        }
        return query;
    }

    @Override
    public boolean getMoreResults() throws SQLException {
        return false;
    }

    @Override
    public void setFetchDirection(int direction) {
    }

    @Override
    public int getFetchDirection() {
        return ResultSet.FETCH_FORWARD;
    }

    @Override
    public void setFetchSize(int rows) {
    }

    @Override
    public int getFetchSize() {
        return 0;
    }

    @Override
    public int getResultSetConcurrency() {
        return ResultSet.CONCUR_READ_ONLY;
    }

    @Override
    public int getResultSetType() {
        return ResultSet.TYPE_FORWARD_ONLY;
    }

    @Override
    public boolean getMoreResults(int current) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    @Override
    public ResultSet getGeneratedKeys() throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    @Override
    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    @Override
    public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    @Override
    public int executeUpdate(String sql, String[] columnNames) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    @Override
    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    @Override
    public boolean execute(String sql, int[] columnIndexes) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    @Override
    public boolean execute(String sql, String[] columnNames) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    @Override
    public int getResultSetHoldability() {
        return ResultSet.CLOSE_CURSORS_AT_COMMIT;
    }

    @Override
    public void setPoolable(boolean poolable) {
    }

    @Override
    public boolean isPoolable() {
        return false;
    }

    @Override
    public void closeOnCompletion() {
        closeOnCompletion = true;
    }
}
